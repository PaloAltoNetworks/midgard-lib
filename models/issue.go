package models

import "fmt"
import "github.com/aporeto-inc/elemental"

// IssueRealmValue represents the possible values for attribute "realm".
type IssueRealmValue string

const (
	// IssueRealmCertificate represents the value Certificate.
	IssueRealmCertificate IssueRealmValue = "Certificate"

	// IssueRealmFacebook represents the value Facebook.
	IssueRealmFacebook IssueRealmValue = "Facebook"

	// IssueRealmGithub represents the value Github.
	IssueRealmGithub IssueRealmValue = "Github"

	// IssueRealmGoogle represents the value Google.
	IssueRealmGoogle IssueRealmValue = "Google"

	// IssueRealmTwitter represents the value Twitter.
	IssueRealmTwitter IssueRealmValue = "Twitter"
)

// IssueIdentity represents the Identity of the object
var IssueIdentity = elemental.Identity{
	Name:     "issue",
	Category: "issue",
}

// IssuesList represents a list of Issues
type IssuesList []*Issue

// Issue represents the model of a issue
type Issue struct {
	// Data contains additional data. The value depends on the issuer type.
	Data string `json:"data" cql:"data,omitempty" bson:"data"`

	// Realm is the realm
	Realm IssueRealmValue `json:"realm" cql:"-" bson:"-"`

	// Token is the token to use for the registration.
	Token string `json:"token" cql:"-" bson:"-"`
}

// NewIssue returns a new *Issue
func NewIssue() *Issue {

	return &Issue{}
}

// Identity returns the Identity of the object.
func (o *Issue) Identity() elemental.Identity {

	return IssueIdentity
}

// Identifier returns the value of the object's unique identifier.
func (o *Issue) Identifier() string {

	return ""
}

func (o *Issue) String() string {

	return fmt.Sprintf("<%s:%s>", o.Identity().Name, o.Identifier())
}

// SetIdentifier sets the value of the object's unique identifier.
func (o *Issue) SetIdentifier(ID string) {

}

// Validate valides the current information stored into the structure.
func (o *Issue) Validate() error {

	errors := elemental.Errors{}

	if err := elemental.ValidateStringInList("realm", string(o.Realm), []string{"Certificate", "Facebook", "Github", "Google", "Twitter"}, false); err != nil {
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return errors
	}

	return nil
}

// SpecificationForAttribute returns the AttributeSpecification for the given attribute name key.
func (Issue) SpecificationForAttribute(name string) elemental.AttributeSpecification {

	return IssueAttributesMap[name]
}

// AttributeSpecifications returns the full attribute specifications map.
func (Issue) AttributeSpecifications() map[string]elemental.AttributeSpecification {

	return IssueAttributesMap
}

// IssueAttributesMap represents the map of attribute for Issue.
var IssueAttributesMap = map[string]elemental.AttributeSpecification{
	"Data": elemental.AttributeSpecification{
		AllowedChoices: []string{},
		Exposed:        true,
		Filterable:     true,
		Format:         "free",
		Name:           "data",
		Orderable:      true,
		Stored:         true,
		Type:           "string",
	},
	"Realm": elemental.AttributeSpecification{
		AllowedChoices: []string{"Certificate", "Facebook", "Github", "Google", "Twitter"},
		Exposed:        true,
		Name:           "realm",
		Required:       true,
		Type:           "enum",
	},
	"Token": elemental.AttributeSpecification{
		AllowedChoices: []string{},
		Autogenerated:  true,
		Exposed:        true,
		Format:         "free",
		Name:           "token",
		ReadOnly:       true,
		Type:           "string",
	},
}
